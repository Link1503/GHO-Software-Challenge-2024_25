package sc.player;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sc.api.plugins.IGameState;
import sc.plugin2025.Move;
import sc.plugin2025.Board;
import sc.plugin2025.Card;
import sc.plugin2025.Field;
import sc.plugin2025.GameRuleLogic;
import sc.plugin2025.GameState;
import sc.shared.GameResult;

import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.List;

public class Logic implements IGameHandler {
  private static final Logger log = LoggerFactory.getLogger(Logic.class);
 

  private GameState gameState;

  public static int[] IndexArrFürFeldtyp(Board Board, Field Feld) {
      int arr[] = new int[64];
      int x = 0;

      for (int i = 0; i < arr.length; i++) {
          if (Board.getField(i) == Feld) {
              arr[x] = i;
              x++;
          } else {
              continue;
          }

      }
      int arr1[] = new int[x];
      for (int i = 0; i < x; i++) {
          arr1[i] = arr[i];
      }
      return arr1;
  }
  public static int[] Zugweite(List<Move> Listmoves, GameState game) {
      int arr[] = new int[Listmoves.size()];
      int i = 0;
      for (Move move : Listmoves) {
          GameState clone = game.clone();
          clone.performMoveDirectly(move);
          arr[i] = clone.getOtherPlayer().getPosition() - game.getCurrentPlayer().getPosition();
          i++;
      }
      return arr;
  }
  public int[] Karten(List<Card> PlayerCards) {
      int[] Karten_Typ = new int[4];
      for (Object karte : PlayerCards) {
          switch (karte.toString()) {
              case "EAT_SALAD" -> Karten_Typ[0]++;
              case "SWAP_CARROTS" -> Karten_Typ[1]++;
              case "HURRY_AHEAD" -> Karten_Typ[2]++;
              case "FALL_BACK" -> Karten_Typ[3]++;
          }
      }
      return Karten_Typ;
  }
 
  public Field[] Spielfeld() {
	
	  Field[] Spielfeld = new Field[65]; 
	  for (int i = 0; i < 65; i++) {
		  Spielfeld[i] = gameState.getBoard().getField(i);
          }
	  return  Spielfeld;	  
  }
  public List<Move> Mögliche_Züge(Move move , GameState game) {
	  GameState clone = game.clone(); 
			clone.performMoveDirectly(move);	
				clone.performMoveDirectly(GegnerZug(clone));	
	  return clone.getSensibleMoves();
  }
  public GameState NewGameState(Move move , GameState game) {
	  GameState clone = game.clone(); 
	  clone.performMoveDirectly(move);	
		clone.performMoveDirectly(GegnerZug(clone));
	  return  clone;
  }
  public Field NewField(Move move , GameState game) {
	  GameState clone = game.clone(); 
	  clone.performMoveDirectly(move);
	  return  clone.getBoard().getField(clone.getOtherPlayer().getPosition());
  }
  
  public List<Move> Filter(List<Move> Moves , GameState game){

	  for(int i = 0; i < Moves.size(); i++) {
		  GameState clone = game.clone(); 
		  clone.performMoveDirectly(Moves.get(i));
				clone.performMoveDirectly(GegnerZug(clone));	

		  int Eigene_Karrotten = clone.getCurrentPlayer().getCarrots();
	      int Gegner_Karroten = clone.getOtherPlayer().getCarrots();
	      int Eigene_Salate = clone.getCurrentPlayer().getSalads();
	      int Gegner_Position = clone.getOtherPlayer().getPosition();
	      int Eigene_Position = clone.getCurrentPlayer().getPosition();
	      Field Eigene_FeldTyp = clone.getBoard().getField(clone.getCurrentPlayer().getPosition());
	      Field Gegner_FeldTyp = clone.getBoard().getField(clone.getOtherPlayer().getPosition());
	      int[] Karten = Karten(clone.getCurrentPlayer().getCards());
	      int[] Vergleich_Karten = Karten(game.getCurrentPlayer().getCards());
	      
	      switch(Eigene_FeldTyp) {
	      case MARKET:{
	    	  if(Karten[0] != Vergleich_Karten[0] ) {   //MARKET EAT_SALAT
	    		  if(Karten[0] >= Eigene_Salate) {
		    		  Moves.remove(i);
		    	  }
	    	  }
	    	  
	      }
	      case SALAD:{
	    	    
	    	  break; 
	      }
	      case HARE:{
	    	 
	    	  break;
	      }
	      case HEDGEHOG:{
	    	 
	    	  break;
	      }
	      case POSITION_2:{
	    	 
	    	  break;
	      }
	      case POSITION_1:{

	    	  break;
	      }
	      case CARROTS:{
	    	 
	    	  break;
	      }
	      case GOAL:{
	    	  
	    	  break;
	      }
	      default:
	          break;
	      }
	      
		}
	  
	  return Moves;  
  }
   public Move Zugauswahl(float[][]Float, Move[][] Züge ) {

      Move[] ZugList = new Move[Züge.length];
      
      for(int i = 0; i < Float.length; i++) {
      	ZugList[i] = Züge[i][0];
      }
      
      float[] Endwert = new float[Float.length];
      for(int i = 0; i < Float.length; i++) {
          Endwert[i] = Float[i][3];
      }
     
      Move Zug = ZugList[0];
      float maxValue = 0.0f; // Startwert setzen

      for (int i = 0; i < Endwert.length; i++) {
          if (Endwert[i] > maxValue) {
              maxValue = Endwert[i];
              Zug = ZugList[i];
          }
      }
      return Zug;
  }
   public float Endwert(float[][] Float ) {
  	
  	float[] Endwert = new float[Float.length];
      for(int i = 0; i < Float.length; i++) {
          Endwert[i] = Float[i][3];
      }
      float maxValue = 0.0f; // Startwert setzen

      for (int i = 0; i < Endwert.length; i++) {
          if (Endwert[i] > maxValue) {
              maxValue = Endwert[i];
          }
      }
      return maxValue;
  }
   public Move GegnerZug(GameState game) {
	   List<Move> GegnerZüge = game.getSensibleMoves();
	   Move GegnerZug = game.getSensibleMoves().get(0);
	   float maxValue = 0.0f; // Startwert setzen
		  for (int i = 0; i < GegnerZüge.size(); i++) { 
		  GameState clone = game.clone();
		  Move Zug = GegnerZüge.get(i);
		  clone.performMoveDirectly(Zug);
		  int Eigene_Karrotten = clone.getOtherPlayer().getCarrots();
	      int Gengner_Karroten = clone.getCurrentPlayer().getCarrots();
	      int Eigene_Salate = clone.getOtherPlayer().getSalads();
	      int Gegner_Position = clone.getCurrentPlayer().getPosition();
	      int Eigene_Position = clone.getOtherPlayer().getPosition();
	      Field Eigene_FeldTyp = clone.getBoard().getField(clone.getOtherPlayer().getPosition());
	      Field Voherige_FeldTyp = game.getBoard().getField(game.getOtherPlayer().getPosition());
	      Field Gegner_FeldTyp = clone.getBoard().getField(clone.getCurrentPlayer().getPosition());
	      int[] Karten =  Karten(game.getCurrentPlayer().getCards());
	      int[] Vergleich_Karten = Karten(clone.getOtherPlayer().getCards());
	      
	      float Floatwert = 0.0f;
	      
	      switch(Eigene_FeldTyp) {
	      case MARKET:{
	    	  
	    	  if(Karten[0] != Vergleich_Karten[0] ) {   //MARKET EAT_SALAT
	    		  Floatwert = 0.3f;
	    		  if(Karten[0] != Vergleich_Karten[0] ) {  
		    		  if(Karten[0] >= Eigene_Salate) {
		    			  Floatwert = 0.0f;
			    	  }
		    	  }
	    	  }
			  if(Karten[1] != Vergleich_Karten[1] ) {   // MARKET SWITCH_CARROTS
				  Floatwert = 0.0f;  
			  }
			  if(Karten[2] != Vergleich_Karten[2] ) {   // MARKET HURRY
				  Floatwert = 0.0f;
			  }
			  if(Karten[3] != Vergleich_Karten[3] ) {   // MARKET FALL_BACK 
				  Floatwert = 0.0f;
			  }
	          break;    
	      }
	      case SALAD:{
	    	  
	    	  if(Eigene_FeldTyp != Voherige_FeldTyp ) { 
	    		  Floatwert = 0.5f; 
	    	  }
	        	
			  if(Eigene_FeldTyp == Voherige_FeldTyp ) {   // EAT_SALAT
				  Floatwert = 0.0f;  
			  }
	    	  
	    	  break; 
	      }
	      case HARE:{
	    	  if(Karten[0] != Vergleich_Karten[0] ) {   //HARE EAT_SALAT
	    		  Floatwert = 0.5f; 
	    	  }
			  if(Karten[1] != Vergleich_Karten[1] ) {   //HARE SWITCH_CARROTS
				  Floatwert = 0.0f;  
			  }
			  if(Karten[2] != Vergleich_Karten[2] ) {   //HARE HURRY
				  Floatwert = 0.0f;
			  }
			  if(Karten[3] != Vergleich_Karten[3] ) {   // HARE FALL_BACK 
				  Floatwert = 0.0f;
			  }
	    	  break;
	      }
	      case HEDGEHOG:{
	    	  Floatwert = 0.15f;
	    	  break;
	      }
	      case POSITION_2:{
	    	  if(Eigene_Position < Gegner_Position ) {    
				  Floatwert = 0.2f;
				  break;
			  }
	    	  else {
	    		  Floatwert = 0.0f;
	    	  }
	    	  break;
	      }
	      case POSITION_1:{
	    	  if(Eigene_Position > Gegner_Position ) {   
				  Floatwert = 0.2f;
				  break;
			  }
	    	  else {
	    		  Floatwert = 0.0f;
	    	  }
	    	  break;
	      }
	      case CARROTS:{
	    	  Floatwert = 0.1f;
	    	  break;
	      }
	      case GOAL:{
	    	  Floatwert = 0.0f;
	    	  break;
	      }
	      default:
	          break;
	      }
          if ( Floatwert > maxValue) {
	         maxValue =  Floatwert;
	         GegnerZug = Zug;
	      }
		 }
       return GegnerZug;
   }

  
  public Move Zugzuortnung(){
	  
	  Move Bester_Zug = null;
	if(gameState.getBoard().getField(gameState.getOtherPlayer().getPosition()) != Field.GOAL) {
	  List<Move> Mögliche_Züge = Filter(gameState.getSensibleMoves(),gameState);
	  Move[][] AlleZüge_Platzhalter = new Move[100000][6];
	  float[][] AlleFloat_Platzhalter = new float[100000][6];
	  int Zähler = 0;
	  for(int i = 0; i < Mögliche_Züge.size(); i++) {	
		      GameState GameState1 = NewGameState(Mögliche_Züge.get(i) , gameState);
			  List<Move> Mögliche_Züge1 = Filter(Mögliche_Züge(Mögliche_Züge.get(i) , gameState),GameState1);
			  float Floatwert =  Floatwert(Mögliche_Züge.get(i),gameState);	  
			  
			  
		  for(int a = 0; a < Mögliche_Züge1.size(); a++) {	
			  GameState GameState2 = NewGameState(Mögliche_Züge1.get(a) , GameState1); 
			  List<Move> Mögliche_Züge2 = Filter(Mögliche_Züge(Mögliche_Züge1.get(a) , GameState1),GameState2) ;
			  float Floatwert1 =  Floatwert(Mögliche_Züge1.get(a),GameState1);
 
		  for(int j = 0; j < Mögliche_Züge2.size(); j++) {
			  
			  float Floatwert2 =  Floatwert(Mögliche_Züge2.get(j),GameState2);
			  
			  
			  AlleZüge_Platzhalter[Zähler][0] = Mögliche_Züge.get(i);
			  AlleZüge_Platzhalter[Zähler][1] = Mögliche_Züge1.get(a);
			  AlleZüge_Platzhalter[Zähler][2] = Mögliche_Züge2.get(j);
			  AlleFloat_Platzhalter[Zähler][0] = Floatwert;
			  AlleFloat_Platzhalter[Zähler][1] = Floatwert1;
			  AlleFloat_Platzhalter[Zähler][2] = Floatwert2;
			  AlleFloat_Platzhalter[Zähler][3] =  FloatwertApassug(Floatwert, Floatwert1, Floatwert2 , GameState2 );
			  Zähler++;
		  }
		 }
	    }
	    
	  
	  Move[][] AlleZüge = new Move[Zähler][6];
	  for (int i = 0; i < Zähler; i++){
          for (int j = 0; j < 5; j++){
        	  AlleZüge[i][j] = AlleZüge_Platzhalter[i][j];
      }
     }
	  float[][] AlleFloat = new float[Zähler][6];
	  for (int i = 0; i < Zähler; i++){
          for (int j = 0; j < 5; j++){
        	  AlleFloat[i][j] = AlleFloat_Platzhalter[i][j];
      }
     }
	  
	 
	  for(int i = 0; i < Mögliche_Züge.size(); i++) {
			if(Field.GOAL == NewField(Mögliche_Züge.get(i), gameState) ) {
				Bester_Zug = Mögliche_Züge.get(i);
				break;
			}
			else {
		      Bester_Zug = Zugauswahl(AlleFloat, AlleZüge);
			}
			
		}
	
	  float Endwert = Endwert(AlleFloat);
	
	  int columnWidth = 55;
	    int columnWidthEndwert = 8;
	    int columnCount = 3;

	    String separator = new String(new char[(columnCount - 1) * (columnWidth + 3) + columnWidthEndwert +4 ]).replace("\0", "_");
	    System.out.println(separator);
	    System.out.printf("| %-" + columnWidth + "s | %-" + columnWidth + "s | %-" + columnWidth + "s |  %-" + columnWidth + "s | \n",
	            "Zug1", "Zug2", "Zug3" , "Endwert");
	    System.out.println(separator);
	    for (int i = 0; i < AlleZüge.length; i++) { 
	    	
	            String ZugFarbe = "\u001B[32m";
	            if(AlleFloat[i][3] != Endwert) {
	                ZugFarbe = "\u001B[0m";
	            }
	        System.out.printf("| %-" + columnWidth + "s | %-" + columnWidth + "s | %-" + columnWidth + "s |  %-" + columnWidth + "s | \n",
	        		AlleZüge[i][0] + " | " + String.format("%.2f", AlleFloat[i][0]),
	        		    	AlleZüge[i][1] + " | "+ String.format("%.2f", AlleFloat[i][1]),
	        						AlleZüge[i][2] + " | "+ String.format("%.2f", AlleFloat[i][2]),
	                                      ZugFarbe + String.format("%.2f", AlleFloat[i][3]) + "\u001B[0m");
	    }
	    System.out.println(separator);
	 }
	
	else if(gameState.getBoard().getField(gameState.getOtherPlayer().getPosition()) == Field.GOAL) {
		
		List<Move> Mögliche_Züge = gameState.getSensibleMoves();
		for(int i = 0; i < Mögliche_Züge.size(); i++) {
			if(Field.GOAL == NewField(Mögliche_Züge.get(i), gameState) ) {
				Bester_Zug = Mögliche_Züge.get(i);
				break;
		
			}
			else {
				Bester_Zug = Mögliche_Züge.get(0);
			}
		}
		
	}
	else {
		List<Move> Mögliche_Züge = gameState.getSensibleMoves();
		Bester_Zug = Mögliche_Züge.get(0);
	}
	  return Bester_Zug;  
  }
  public float[] Floatwerte_Anpassung ( float[] Floatwerte, String Züge[] , int[] Züge_int){
  	
       boolean Terminate = false;
		
	
  	for(int i = 0; i < Floatwerte.length - 1  && Terminate != true; i++) {
  		
  		
  		
  	}
      return Floatwerte; 
  }
  
  public float FloatwertApassug(float Float1 ,float Float2, float Float3, GameState game3) {
	   
      float Endwert = Float1 + Float2/1.5f +Float3/2f;
      
	  return Endwert;
  }

  public float Floatwert(Move Zug , GameState game) {
	  
	  GameState clone = game.clone();
	  clone.performMoveDirectly(Zug);
	  int Eigene_Karrotten = clone.getOtherPlayer().getCarrots();
      int Gengner_Karroten = clone.getCurrentPlayer().getCarrots();
      int Eigene_Salate = clone.getOtherPlayer().getSalads();
      int Gegner_Position = clone.getCurrentPlayer().getPosition();
      int Eigene_Position = clone.getOtherPlayer().getPosition();
      Field Eigene_FeldTyp = clone.getBoard().getField(clone.getOtherPlayer().getPosition());
      Field Voherige_FeldTyp = game.getBoard().getField(game.getOtherPlayer().getPosition());
      Field Gegner_FeldTyp = clone.getBoard().getField(clone.getCurrentPlayer().getPosition());
      int[] Karten =  Karten(game.getCurrentPlayer().getCards());
      int[] Vergleich_Karten = Karten(clone.getOtherPlayer().getCards());
      float V1 = 0.0f;
      float V2 = 0.0f;
      float V3 = 0.0f;
      float V4 = 0.0f;
      float V5 = 0.0f;
      
      float Floatwert = 0.0f;
      
      if(Gegner_Position + GameRuleLogic.INSTANCE.calculateMoveableFields(Gengner_Karroten) > Eigene_Position) {
    	 V1 = -0.2f;
      }
      else {
    	 V1 = 0.1f;
      }
      if(Eigene_Position < Gegner_Position && Gegner_FeldTyp == Field.POSITION_2 ){
     	 V2 = 0.2f;
       }
       else {
     	 V2 = 0.0f;
       }
      if(Gegner_Position - (clone.getBoard().getPreviousField(Field.HEDGEHOG, Gegner_Position) != null ? clone.getBoard().getPreviousField(Field.HEDGEHOG, Gegner_Position) : 0) 
    		  < Eigene_Position){
     	 V3 = -0.1f;
       }
       else {
     	 V3 = 0.1f;
       }
      if(Eigene_Position > Gegner_Position && Gegner_FeldTyp == Field.POSITION_1 ){
     	 V4 = 0.2f;
       }
       else {
     	 V4 = 0.0f;
       }
      if(Eigene_Salate == 0 && Eigene_FeldTyp != Field.HEDGEHOG){
      	 V5 = 0.2f + (clone.getOtherPlayer().getPosition() -  game.getOtherPlayer().getPosition())/100f;
        }
        else {
      	 V5 = 0.0f;
        }
      
      switch(Eigene_FeldTyp) {
      case MARKET:{
    	  
    	  if(Karten[0] != Vergleich_Karten[0] ) {   //MARKET EAT_SALAT
    		  Floatwert = 0.5f + V4 + V2;
    	  }
		  if(Karten[1] != Vergleich_Karten[1] ) {   // MARKET SWITCH_CARROTS
			  Floatwert = (0.6f - Eigene_Position/130f) - Karten[1] + V4 + V2;  
		  }
		  if(Karten[2] != Vergleich_Karten[2] ) {   // MARKET HURRY
			  Floatwert = 0.0f + V4 + V2;
		  }
		  if(Karten[3] != Vergleich_Karten[3] ) {   // MARKET FALL_BACK 
			  Floatwert = 0.0f + V4 + V2;
		  }
          break;    
      }
      case SALAD:{
    	  
    	  if(Eigene_FeldTyp != Voherige_FeldTyp ) {   //SALAT
    		  if(Eigene_Position < Gegner_Position ) {   // HARE FALL_BACK 
    			  Floatwert = 1.0f + V2;
    		  }
        	  else {
        		  Floatwert = 0.5f + V4;
        	  }
    	  }
		  if(Eigene_FeldTyp == Voherige_FeldTyp ) {   // EAT_SALAT
			  Floatwert = 0.0f;  
		  }
    	  
    	  break; 
      }
      case HARE:{
    	  if(Karten[0] != Vergleich_Karten[0] ) {   //HARE EAT_SALAT
    		  if(Eigene_Position < Gegner_Position ) {   // HARE FALL_BACK 
    			  Floatwert = 1.0f + V2;
    		  }
        	  else {
        		  Floatwert = 0.5f + V4;
        	  }
    	  }
		  if(Karten[1] != Vergleich_Karten[1] ) {   //HARE SWITCH_CARROTS
			  Floatwert = 0.1f + V4 + V2;  
		  }
		  if(Karten[2] != Vergleich_Karten[2] ) {   //HARE HURRY
			  Floatwert = 0.0f;
		  }
		  if(Karten[3] != Vergleich_Karten[3] ) {   // HARE FALL_BACK 
			  Floatwert = 0.0f;
		  }
    	  break;
      }
      case HEDGEHOG:{
    	  Floatwert = 0.15f + V2;
    	  break;
      }
      case POSITION_2:{
    	  if(Eigene_Position < Gegner_Position ) {    
			  Floatwert = 0.2f + V3 + V5;
			  break;
		  }
    	  else {
    		  Floatwert = -0.1f + V5;
    	  }
    	  break;
      }
      case POSITION_1:{
    	  if(Eigene_Position > Gegner_Position ) {   
			  Floatwert = 0.2f + V1 + V4 + V5;
			  break;
		  }
    	  else {
    		  Floatwert = -0.1f + V5;
    	  }
    	  break;
      }
      case CARROTS:{
    	  if(clone.getOtherPlayer().getPosition() ==  game.getOtherPlayer().getPosition()) {
    		  Floatwert = 0.1f;
    	  }
    	  if(clone.getOtherPlayer().getPosition() ==  game.getOtherPlayer().getPosition()) {
    		  Floatwert = 0.1f + V4 + V2 + V5;
    	  }
    	  break;
      }
      case GOAL:{
    	  Floatwert = 5.0f;
    	  break;
      }
      default:
          break;
      }
      return Floatwert;
  }
  
  public int[] Zug() {
	  
	  Field[] Spielfeld = Spielfeld();
	  int[] int_Salte = IndexArrFürFeldtyp(gameState.getBoard(), Field.SALAD);
	  int[] int_Hasen = IndexArrFürFeldtyp(gameState.getBoard(), Field.HARE);
	  int[] int_Markt = IndexArrFürFeldtyp(gameState.getBoard(), Field.MARKET);
	  int[] int_Pos1 = IndexArrFürFeldtyp(gameState.getBoard(), Field.POSITION_1);
	  int[] int_Pos2 = IndexArrFürFeldtyp(gameState.getBoard(), Field.POSITION_2);
	  int[] int_Igel = IndexArrFürFeldtyp(gameState.getBoard(), Field.HEDGEHOG);
	  int[] int_Karroten = IndexArrFürFeldtyp(gameState.getBoard(), Field.CARROTS);
	  
	  
	return null; 
  }

  
  
  public Move calculateMove() {
    long startTime = System.currentTimeMillis();
    log.info("Es wurde ein Zug von {} angefordert.", gameState.getCurrentTeam());
    
    int Eigene_Karrotten = gameState.getCurrentPlayer().getCarrots();
    int Gengner_Karroten = gameState.getOtherPlayer().getCarrots();
    int Eigene_Salate = gameState.getCurrentPlayer().getSalads();
    int Gegner_Position = gameState.getOtherPlayer().getPosition();
    int Eigene_Position = gameState.getCurrentPlayer().getPosition();
    Field Eigne_FeldTyp = gameState.getBoard().getField(gameState.getCurrentPlayer().getPosition());
    Field Gegner_FeldTyp = gameState.getBoard().getField(gameState.getOtherPlayer().getPosition());
    String Gespielte_Schleife = "nichts";
    int[] Karten  = Karten(gameState.getCurrentPlayer().getCards());
    int[] GegnerKarten  = Karten(gameState.getOtherPlayer().getCards());
    Field[] Spielfeld = Spielfeld();
    List<Move> possibleMoves = gameState.getSensibleMoves();
    int move_int = 0;
    Move Bester_Zug = Zugzuortnung();
    
    
    Move move =  Bester_Zug;
    
    System.out.println("\033[1;36mSpielrunde: " + gameState.getTurn() + "\u001B[0m | Menge an Karrotten: " + Eigene_Karrotten + "\n");
    System.out.println("Mögliche Züge: (gesammt: " + possibleMoves.size() + ") " + possibleMoves + "\n");
    System.out.println("Gespielter Zug: " + move);
    System.out.println("Eigendes Feld: " + Eigne_FeldTyp + " auf Position: " + Eigene_Position + "\n");
    System.out.println("Karten =  " + "Saladfressen: " + Karten[0] + " | " + "Karotten tauschen: " + Karten[1] + " | " + "Zurückfallen: " + Karten[2] + " | " + "Vorrücken: " + Karten[3] + "\n");
    System.out.println("Karten-Gegner =  " + "Saladfressen: " + GegnerKarten[0] + " | " + "Karotten tauschen: " + GegnerKarten[1] + " | " + "Zurückfallen: " + GegnerKarten[2] + " | " + "Vorrücken: " + GegnerKarten[3] + "\n");
    System.out.println("Spielfeld: " + Arrays.toString(Spielfeld));
   
    log.info("Sende {} nach {}ms.", move, System.currentTimeMillis() - startTime);
    return move;
  }

  /** Ein neuer Spielstatus ist verfügbar, d.h. ein Zug wurde erfolgreich ausgeführt. */
  @Override
  public void onUpdate(IGameState gameState) {
    this.gameState = (GameState) gameState;
    log.info("Zug: {} Dran: {}", gameState.getTurn(), gameState.getCurrentTeam());
  }

  /** Wird aufgerufen, wenn das Spiel beendet ist. */
  public void onGameOver(GameResult data) {
    log.info("Das Spiel ist beendet, Ergebnis: {}", data);
  }

  /** Wird aufgerufen, wenn der Server einen Fehler meldet.
   * Bedeutet auch den Abbruch des Spiels. */
  @Override
  public void onError(String error) {
    log.warn("Fehler: {}", error);
  }
}
